#!/bin/sh
PYTHON=python
# Target build script

if [ $# -lt 1 ]; then
	echo "usage: buildtarget target [path-to-coreboot]"
	exit 1
fi

if [ $# -gt 1 ]; then
	lbpath=$2
else
	lbpath=`pwd`
	lbpath=`dirname $lbpath`
fi

target_dir=$lbpath/targets
config_lb=$1
config_dir=$lbpath/util/newconfig
yapps2_py=$config_dir/yapps2.py
config_g=$config_dir/config.g

if [ ! -d $target_dir ]; then
	echo "Target directory not found"
	exit 1
fi

cd $target_dir

if [ ! -f $config_lb ]; then
	config_lb=$1/Config.lb
fi
if [ ! -f $config_lb ]; then
	echo "No target config file found"
	echo "Tried both $1 and $config_lb"
	exit 1
fi

build_dir=`dirname $config_lb`/`sed -n -e 's/^target \(.*\)$/\1/p' $config_lb`
echo "build_dir=$build_dir"
config_py=$build_dir/config.py

if [ ! -d $build_dir ] ; then
	mkdir -p $build_dir
fi
if [ ! -f $config_py ]; then
	echo "No coreboot config script found. Rebuilding it.."
	$PYTHON $yapps2_py $config_g $config_py
fi

# make sure config.py is up-to-date

export PYTHONPATH=$config_dir
$PYTHON $config_py $config_lb $lbpath

# now start checking for distro-specific breakage. 
## This check is for the no stack protector mess.
EXTRA_CFLAGS=

if [ -z "$CC" ]; then
       CC=gcc
fi

$CC -fno-stack-protector -S -xc /dev/null -o .$$.tmp 2>/dev/null

if [ $? -eq 0 ]; then
       EXTRA_CFLAGS=-fno-stack-protector
fi

rm -rf .$$.tmp

# The linker output fd depends on the gcc version.
#  1) 'ld-2.15 --help' and 'gcc-4.0 -Wl,--help' use STDOUT.
#  2) 'gcc-3.3 --help' and 'gcc-3.4 -Wl,--help' use STDERR.
# Thus older versions of GCC (presumably 3.x) implement a redirection of
# output to stderr. Re-redirect stderr to stdout to work always.
if $CC -Wl,--help 2>&1 | grep -q build-id; then
	EXTRA_LFLAGS="$EXTRA_LFLAGS -Wl,--build-id=none"
fi

for i in $build_dir/Makefile.settings $build_dir/*/Makefile.settings
do
	echo DISTRO_CFLAGS+=$EXTRA_CFLAGS >>$i
	echo DISTRO_LFLAGS+=$EXTRA_LFLAGS >>$i
done

exit $?
