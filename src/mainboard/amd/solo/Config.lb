#
###
### Build code to export a CMOS option table
###
default HAVE_OPTION_TABLE=1
option HAVE_MP_TABLE=0
####
#### Build options
####
#
###
### Location of the DIMM EEPROMS on the SMBUS
### This is fixed into a narrow range by the DIMM package standard.
###
option SMBUS_MEM_DEVICE_START=(0xa << 3)
option SMBUS_MEM_DEVICE_END=(SMBUS_MEM_DEVICE_START +1)
option SMBUS_MEM_DEVICE_INC=1
default CONFIG_CONSOLE_VGA=0
default CONFIG_CONSOLE_LOGBUF=0
default CONFIG_CONSOLE_SROM=0
default CONFIG_SMP=0
default CONFIG_UDELAY_TSC=0
#
###
### Customize our winbond superio chip for this motherboard
###
option SIO_BASE=0x2e
option SIO_SYSTEM_CLK_INPUT=0
option CONFIG_CONSOLE_SERIAL8250=0
#
###
### Build code for the fallback boot
###
option HAVE_FALLBACK_BOOT=1
#
###
### Build code to reset the motherboard from linuxBIOS
###
## option HAVE_HARD_RESET=1
#
###
### Build code to export a programmable irq routing table
###
option HAVE_PIRQ_TABLE=1
option IRQ_SLOT_COUNT=7
#
###
### Build code to export an x86 MP table
### Useful for specifying IRQ routing values
###
##option HAVE_MP_TABLE=1
#
###
### Do not build special code for the keyboard
###
default NO_KEYBOARD=1
#
###
### Build code for SMP support
### Only worry about 2 micro processors
###
##option CONFIG_SMP=1
option MAX_CPUS=1
#
###
### Build code to setup a generic IOAPIC
###
option CONFIG_IOAPIC=1
#
###
### MEMORY_HOLE instructs earlymtrr.inc to
### enable caching from 0-640KB and to disable 
### caching from 640KB-1MB using fixed MTRRs 
###
### Enabling this option breaks SMP because secondary
### CPU identification depends on only variable MTRRs
### being enabled.
###
option MEMORY_HOLE=0
#
###
### Enable both fixed and variable MTRRS
### When we setup MTRRs in mtrr.c  
###
### We must setup the fixed mtrrs or we confuse SMP secondary
### processor identification
###
option ENABLE_FIXED_AND_VARIABLE_MTRRS=1
#
###
### Clean up the motherboard id strings
###
option MAINBOARD_PART_NUMBER="Solo7"
option MAINBOARD_VENDOR="AMD"
#
###
### Let Assembly code know where on the pci bus the AMD southbridge is
###
option AMD8111_DEV=0x3800
#
###
### Call the final_mainboard_fixup function
###
option FINAL_MAINBOARD_FIXUP=1
#
###
### Figure out which type of linuxBIOS image to build
### If we aren't a fallback image we must be a normal image
### This is useful for optional includes
###
default USE_FALLBACK_IMAGE=0
option USE_NORMAL_IMAGE=(! USE_FALLBACK_IMAGE)
#
####
#### LinuxBIOS layout values
####
#
### ROM_SIZE is the size of boot ROM that this board will use.
option ROM_SIZE=262144
#
### ROM_IMAGE_SIZE is the amount of space to allow linuxBIOS to occupy.
option ROM_IMAGE_SIZE=65535
#
###
### Use a small 8K stack
###
option STACK_SIZE=0x2000
#
###
### Use a small 8K heap
###
option HEAP_SIZE=0x2000
#
###
### Only use the option table in a normal image
###
option USE_OPTION_TABLE=!USE_FALLBACK_IMAGE
#
###
### Compute the location and size of where this firmware image
### (linuxBIOS plus bootloader) will live in the boot rom chip.
###
default FALLBACK_SIZE=65536
if USE_FALLBACK_IMAGE 
  option ROM_SECTION_SIZE  = FALLBACK_SIZE
  option ROM_SECTION_OFFSET= (ROM_SIZE - FALLBACK_SIZE)
end
if USE_NORMAL_IMAGE
  option ROM_SECTION_SIZE  = (ROM_SIZE - FALLBACK_SIZE)
  option ROM_SECTION_OFFSET= 0
end
#
###
### Compute the start location and size size of
### The linuxBIOS bootloader.
###
option PAYLOAD_SIZE            = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
option CONFIG_ROM_STREAM_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
option CONFIG_ROM_STREAM     = 1
#
###
### Compute where this copy of linuxBIOS will start in the boot rom
###
option _ROMBASE      = (CONFIG_ROM_STREAM_START + PAYLOAD_SIZE)
#
###
### Compute a range of ROM that can cached to speed up linuxBIOS,
### execution speed.
###
##expr XIP_ROM_SIZE = 65536
##expr XIP_ROM_BASE = _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE
##option XIP_ROM_SIZE=65536
##option XIP_ROM_BASE=0xffff0000
#
## XIP_ROM_SIZE && XIP_ROM_BASE values that work.
##option XIP_ROM_SIZE=0x8000
##option XIP_ROM_BASE=0xffff8000
#
###
### Compute where the SMP startup code needs to live
### FIXME I don't see how to make this work for the normal image....
###
option START_CPU_SEG=0xf0000
#
#
###
### Set all of the defaults for an x86 architecture
###
#
#
###
### Build the objects we have code for in this directory.
###
##object mainboard.o
driver mainboard.o
object static_devices.o
if HAVE_MP_TABLE object mptable.o end
if HAVE_PIRQ_TABLE object irq_tables.o end
#
arch i386 end
cpu k8 end
#
option DEBUG=1
default USE_FALLBACK_IMAGE=1
option A=(1+2)
option B=0xa
#
###
### Build our 16 bit and 32 bit linuxBIOS entry code
###
mainboardinit cpu/i386/entry16.inc
mainboardinit cpu/i386/entry32.inc
ldscript /cpu/i386/entry16.lds
ldscript /cpu/i386/entry32.lds
#
###
### Build our reset vector (This is where linuxBIOS is entered)
###
if USE_FALLBACK_IMAGE 
  mainboardinit cpu/i386/reset16.inc 
  ldscript /cpu/i386/reset16.lds 
end

if USE_NORMAL_IMAGE
  mainboardinit cpu/i386/reset32.inc 
  ldscript /cpu/i386/reset32.lds 
end
#
#### Should this be in the northbridge code?
#mainboardinit archi386/lib/cpu_reset.inc
#
###
### Include an id string (For safe flashing)
###
mainboardinit arch/i386/lib/id.inc
ldscript /arch/i386/lib/id.lds
#
####
#### This is the early phase of linuxBIOS startup 
#### Things are delicate and we test to see if we should
#### failover to another image.
####
option MAX_REBOOT_CNT=2
##ldscript arch/i386/lib/failover.lds USE_FALLBACK_IMAGE
#
###
### Setup our mtrrs
###
mainboardinit cpu/k8/earlymtrr.inc
#
#
###
### Only the bootstrap cpu makes it here.
### Failover if we need to 
###
#
if USE_FALLBACK_IMAGE
  mainboardinit southbridge/amd/amd8111/cmos_boot_failover.inc 
end
#
####
#### O.k. We aren't just an intermediary anymore!
####
#
###
### When debugging disable the watchdog timer
###
##option MAXIMUM_CONSOLE_LOGLEVEL=7
#default MAXIMUM_CONSOLE_LOGLEVEL=7
#option DISABLE_WATCHDOG= (MAXIMUM_CONSOLE_LOGLEVEL >= 8) 
#if DISABLE_WATCHDOG
#  mainboardinit southbridgeamd/amd8111/disable_watchdog.inc 
#end
#
###
### Setup the serial port
###
#mainboardinit superiowinbond/w83627hf/setup_serial.inc
mainboardinit pc80/serial.inc
mainboardinit arch/i386/lib/console.inc
if USE_FALLBACK_IMAGE mainboardinit archi386/lib/noop_failover.inc  end
#
###
### Romcc output
###
#makerule ./failover.E dep "$(MAINBOARD)/failover.c" act "$(CPP) -I$(TOP)/src $(CPPFLAGS) $(MAINBOARD)/failover.c > ./failever.E"
#makerule ./failover.inc dep "./romcc ./failover.E" act "./romcc -O ./failover.E > failover.inc"
#mainboardinit .failover.inc
makerule ./auto.E dep "$(MAINBOARD)/auto.c" act "$(CPP) -I$(TOP)/src -$(ROMCCPPFLAGS) $(CPPFLAGS) $(MAINBOARD)/auto.c > ./auto.E"
makerule ./auto.inc dep "./romcc ./auto.E" act "./romcc -O ./auto.E > auto.inc"
mainboardinit ./auto.inc
#
###
### Setup RAM
###
mainboardinit ram/ramtest.inc
mainboardinit southbridge/amd/amd8111/smbus.inc
mainboardinit sdram/generic_dump_spd.inc
#
###
### Include the secondary Configuration files 
###
northbridge amd/amdk8
end
southbridge amd/amd8111
end
#mainboardinit archi386/smp/secondary.inc
superio NSC/pc87360
	register "com1={1} com2={0} floppy=1 lpt=1 keyboard=1"
end
dir /pc80
##dir /src/superio/winbond/w83627hf
cpu p5 end
cpu p6 end
cpu k7 end
cpu k8 end
