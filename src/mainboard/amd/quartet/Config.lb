##
## Compute the location and size of where this firmware image
## (linuxBIOS plus bootloader) will live in the boot rom chip.
##
if USE_FALLBACK_IMAGE
	default ROM_SECTION_SIZE   = FALLBACK_SIZE
	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
else
	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
	default ROM_SECTION_OFFSET = 0
end

##
## Compute the start location and size size of
## The linuxBIOS bootloader.
##
default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
default CONFIG_ROM_STREAM_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)

##
## Compute where this copy of linuxBIOS will start in the boot rom
##
default _ROMBASE      = ( CONFIG_ROM_STREAM_START + PAYLOAD_SIZE )

##
## Compute a range of ROM that can cached to speed up linuxBIOS,
## execution speed.
##
## XIP_ROM_SIZE must be a power of 2.
## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
##
default XIP_ROM_SIZE=65536
default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )

arch i386 end 

##
## Build the objects we have code for in this directory.
##

driver mainboard.o
if HAVE_MP_TABLE object mptable.o end
if HAVE_PIRQ_TABLE object irq_tables.o end

##
## Romcc output
##
makerule ./failover.E
	depends "$(MAINBOARD)/failover.c ./romcc" 
	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
end

makerule ./failover.inc
	depends "$(MAINBOARD)/failover.c ./romcc"
	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
end

makerule ./auto.E 
	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
	action	"./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
end
makerule ./auto.inc 
	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
	action	"./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
end

##
## Build our 16 bit and 32 bit linuxBIOS entry code
##
mainboardinit cpu/x86/16bit/entry16.inc
mainboardinit cpu/x86/32bit/entry32.inc
ldscript /cpu/x86/16bit/entry16.lds
ldscript /cpu/x86/32bit/entry32.lds

##
## Build our reset vector (This is where linuxBIOS is entered)
##
if USE_FALLBACK_IMAGE 
	mainboardinit cpu/x86/16bit/reset16.inc
	ldscript /cpu/x86/16bit/reset16.lds
else
	mainboardinit cpu/x86/32bit/reset32.inc
	ldscript /cpu/x86/32bit/reset32.lds
end

### Should this be in the northbridge code?
mainboardinit arch/i386/lib/cpu_reset.inc

##
## Include an id string (For safe flashing)
##
mainboardinit arch/i386/lib/id.inc
ldscript /arch/i386/lib/id.lds

###
### This is the early phase of linuxBIOS startup 
### Things are delicate and we test to see if we should
### failover to another image.
###
if USE_FALLBACK_IMAGE
	ldscript /arch/i386/lib/failover.lds 
	mainboardinit ./failover.inc
end

###
### O.k. We aren't just an intermediary anymore!
###

##
## Setup RAM
##
mainboardinit cpu/x86/fpu/enable_fpu.inc
mainboardinit cpu/x86/mmx/enable_mmx.inc
mainboardinit cpu/x86/sse/enable_sse.inc
mainboardinit ./auto.inc
mainboardinit cpu/x86/sse/disable_sse.inc
mainboardinit cpu/x86/mmx/disable_mmx.inc

##
## Include the secondary Configuration files 
##
dir /pc80
config chip.h

chip northbridge/amd/amdk8/root_complex
	device pci_domain 0 on
		chip northbridge/amd/amdk8 # mc0
			device pci 18.0 on end
			device pci 18.0 on end
			device pci 18.0 on 
				chip southbridge/amd/amd8111
					device pci 0.0 on
						device pci 0.0 on end
						device pci 0.1 on end
						device pci 0.2 on end
						device pci 1.0 on end
					end
					device pci 1.0 on 
						chip superio/NSC/pc87360
							device pnp 2e.0 off     # Floppy 
								 io 0x60 = 0x3f0
								irq 0x70 = 6
								drq 0x74 = 2
							end
							device pnp 2e.1 off     # Parallel Port
								 io 0x60 = 0x378
								irq 0x70 = 7
							end
							device pnp 2e.2 off     # Com 2
								 io 0x60 = 0x2f8
								irq 0x70 = 3
							end
							device pnp 2e.3 on      # Com 1
								 io 0x60 = 0x3f8
								irq 0x70 = 4
							end
							device pnp 2e.4 off end # SWC
							device pnp 2e.5 off end # Mouse
							device pnp 2e.6 on      # Keyboard
								 io 0x60 = 0x60
								 io 0x62 = 0x64
								irq 0x70 = 1
							end
							device pnp 2e.7 off end # GPIO
							device pnp 2e.8 off end # ACB
							device pnp 2e.9 off end # FSCM
							device pnp 2e.a off end # WDT  
						end
					end
					device pci 1.1 on end
					device pci 1.2 on end
					device pci 1.3 on end
					device pci 1.5 on end
					device pci 1.6 on end
				end # 8111
			end # device pci 18.0
			device pci 18.1 on end
			device pci 18.2 on end
			device pci 18.3 on end
		end
		chip northbridge/amd/amdk8 # mc1
			device pci 19.0 on end
			device pci 19.0 on 
				chip southbridge/amd/amd8131 # amd8131_0
					device pci 0.0 on end
					device pci 0.1 on end
					device pci 1.0 on end
					device pci 1.1 on end
				end
				chip southbridge/amd/amd8131 # amd8131_1
					device pci 0.0 on end
					device pci 0.1 on end
					device pci 1.0 on end
					device pci 1.1 on end
				end
			end
			device pci 19.0 on end
			device pci 19.1 on end
			device pci 19.2 on end
			device pci 19.3 on end
		end

		chip northbridge/amd/amdk8 # mc2
			device pci 1a.0 on end
			device pci 1a.0 on end
			device pci 1a.0 on end
			device pci 1a.1 on end
			device pci 1a.2 on end
			device pci 1a.3 on end
		end

		chip northbridge/amd/amdk8 # mc3
			device pci 1b.0 on end
			device pci 1b.0 on end
			device pci 1b.0 on end
			device pci 1b.1 on end
			device pci 1b.2 on end
			device pci 1b.3 on end
		end
	end # pci_domain 0
	device apic_cluster 0 on
		chip cpu/amd/socket_940
			device apic 0 on end
		end
		chip cpu/amd/socket_940
			device apic 1 on end
		end 		
		chip cpu/amd/socket_940
			device apic 2 on end
		end 		
		chip cpu/amd/socket_940
			device apic 3 on end
		end
	end
end

