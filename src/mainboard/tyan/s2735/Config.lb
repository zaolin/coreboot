##
## Compute the location and size of where this firmware image
## (coreboot plus bootloader) will live in the boot rom chip.
##
if USE_FALLBACK_IMAGE
	default ROM_SECTION_SIZE   = FALLBACK_SIZE
	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
else
	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
	default ROM_SECTION_OFFSET = 0
end

##
## Compute the start location and size size of
## The coreboot bootloader.
##
default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
default CONFIG_ROM_PAYLOAD     = 1

##
## Compute where this copy of coreboot will start in the boot rom
##
default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )

##
## Compute a range of ROM that can cached to speed up coreboot,
## execution speed.
##
## XIP_ROM_SIZE must be a power of 2.
## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
##
default XIP_ROM_SIZE=65536
default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )

arch i386 end 

##
## Build the objects we have code for in this directory.
##

driver mainboard.o
if HAVE_MP_TABLE object mptable.o end
if HAVE_PIRQ_TABLE object irq_tables.o end
object reset.o
if CONFIG_USE_INIT

makerule ./auto.o
        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
        action "$(CC) $(DISTRO_CFLAGS) $(CFLAGS) $(CPPFLAGS) -I$(TOP)/src -I. -nostdinc -nostdlib -fno-builtin -Wall -Os -c $(MAINBOARD)/cache_as_ram_auto.c -o $@"
end

else

makerule ./auto.inc
        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
        action "$(CC) $(DISTRO_CFLAGS) $(CFLAGS) $(CPPFLAGS) $(DEBUG_CFLAGS) -I$(TOP)/src -I. -nostdinc -nostdlib -fno-builtin -Wall -Os -c -S $(MAINBOARD)/cache_as_ram_auto.c -o $@"
        action "perl -e 's/\.rodata/.rom.data/g' -pi $@"
        action "perl -e 's/\.text/.section .rom.text/g' -pi $@"
end

end

##
## Build our 16 bit and 32 bit coreboot entry code
##
mainboardinit cpu/x86/16bit/entry16.inc
mainboardinit cpu/x86/32bit/entry32.inc
ldscript /cpu/x86/16bit/entry16.lds
        if CONFIG_USE_INIT
                ldscript /cpu/x86/32bit/entry32.lds
        end

        if CONFIG_USE_INIT
                ldscript      /cpu/x86/car/cache_as_ram.lds
        end


##
## Build our reset vector (This is where coreboot is entered)
##
if USE_FALLBACK_IMAGE 
	mainboardinit cpu/x86/16bit/reset16.inc 
	ldscript /cpu/x86/16bit/reset16.lds 
else
	mainboardinit cpu/x86/32bit/reset32.inc 
	ldscript /cpu/x86/32bit/reset32.lds 
end

##
## Include an id string (For safe flashing)
##
mainboardinit arch/i386/lib/id.inc
ldscript /arch/i386/lib/id.lds

##
## Setup Cache-As-Ram
##
mainboardinit cpu/x86/car/cache_as_ram.inc

###
### This is the early phase of coreboot startup 
### Things are delicate and we test to see if we should
### failover to another image.
###
if USE_FALLBACK_IMAGE
       ldscript /arch/i386/lib/failover.lds
end

##
## Setup RAM
##
if CONFIG_USE_INIT
initobject auto.o
else
mainboardinit ./auto.inc
end

##
## Include the secondary Configuration files 
##
config chip.h

# sample config for tyan/s2735
chip northbridge/intel/e7501
        device pci_domain 0 on
		device pci 0.0 on end
        	device pci 0.1 on end
        	device pci 2.0 on
        		chip southbridge/intel/i82870
        	        	device pci 1c.0 on end
		                device pci 1d.0 on 
					chip drivers/pci/onboard
                                        	device pci 1.0 on end # intel lan
                                                device pci 1.1 on end
                                        end
				end
        	                device pci 1e.0 on end
        	                device pci 1f.0 on end
        		end
		end
        	device pci 6.0 on end
        	chip southbridge/intel/i82801er
        		device pci 1d.0 on end
		        device pci 1d.1 on end
        	        device pci 1d.2 on end
        	        device pci 1d.3 on end
		        device pci 1d.7 on end
		        device pci 1e.0 on 
                        	chip drivers/pci/onboard
                                	device pci 1.0 on end # intel lan 10/100
                                end
                                chip drivers/pci/onboard
                                        device pci 2.0 on end # ati 
                                end
			end
		        device pci 1f.0 on
				chip superio/winbond/w83627hf
                                	device pnp 2e.0 on #  Floppy
                                        	io 0x60 = 0x3f0
                                                irq 0x70 = 6
                                                drq 0x74 = 2
                                        end
	                                device pnp 2e.1 off #  Parallel Port
                                                io 0x60 = 0x378
                                                irq 0x70 = 7
                                        end
                                        device pnp 2e.2 on #  Com1
        	                                io 0x60 = 0x3f8
                                                irq 0x70 = 4
                                        end
                                        device pnp 2e.3 on #  Com2
                                                io 0x60 = 0x2f8
                                                irq 0x70 = 3
                                        end
                                        device pnp 2e.5 on #  Keyboard
                                                io 0x60 = 0x60
                                                io 0x62 = 0x64
                                                irq 0x70 = 1
                                                irq 0x72 = 12
                                        end
                                        device pnp 2e.6 off #  CIR
                                                io 0x60 = 0x100
                                        end
                                        device pnp 2e.7 off #  GAME_MIDI_GIPO1
                                                io 0x60 = 0x220
                                                io 0x62 = 0x300
                                                irq 0x70 = 9
                                        end                               
                                        device pnp 2e.8 off end #  GPIO2
                                        device pnp 2e.9 off end #  GPIO3
                                        device pnp 2e.a off end #  ACPI
                                        device pnp 2e.b on #  HW Monitor
                                                io 0x60 = 0x290
                                                irq 0x70 = 5
                                        end
				end
		        end
		        device pci 1f.1 off end
        	        device pci 1f.2 on end
        	        device pci 1f.3 on end
        		device pci 1f.5 off end
		        device pci 1f.6 off end
		end # SB
        end # PCI_DOMAIN
        device apic_cluster 0 on
                chip cpu/intel/socket_mPGA604_533Mhz
                        device apic 0 on end
                end
                chip cpu/intel/socket_mPGA604_533Mhz
                        device apic 6 on end
                end
        end
end

